**코멘트: 상어 중학교 문제 (첫날 보고 안돼서 다음날 다시 시도함)**

요약: 
  1. bfs+구현문제
  2. 특별했던 점은: 모든 칸에 대해 visited해주는게 아니라, 인접그룹 체크하는 bfs 수행할 때는 원래대로 visited처리하지만 무지개블록은 다음 그룹에 또 속할 수 있으므로 그룹 형성 후 visited를 취소해줘야함
  3. 2차원 배열 반시계 90도 회전 구현 -> 규칙찾기는 쉽지만 시간 단축을 위해 외워둘 필요성도 있을듯
  4. 전체 group 리스트에 리스트를 추가하는 것 -> group리스트에 속하는 그룹 g에 대해 [일반블록개수,무지개블록개수,전체블록행열 저장하는 리스트(행,열)]로 저장함으로써 한번에 sort하는 것
  5. gravity 구현에 있어서, for문 안에 while문을 넣어서 움직이면서 다음행이 계속 인덱스 내에 속하고 -2(빈칸)인 경우 행을 더하면서 진행해주는 부분을 알게됨



처음 풀 때는 무지개 블록에 대해서 중복 그룹을 형성할 수 있다는 것을 모르고 풀려고 했다가 틀릴 뻔 했다. -> 이렇듯 문제 조건을 처음부터 잘 확인해야한다.

그리고 visited 배열 체크하는게 헷갈렸다. 처음에는 일반블록에 대해서는 전체 visited로 관리하고, bfs 수행할 때는 그룹 내에서 방문 체크 해줘야 하니까 groupvisited 배열을 따로 만들어서 이중으로 체크하려고 했는데 비효율적인 것 같았다. 
=> 그래서 전체 일반블록 체크하는 visited 배열로 사용하되, bfs끝나면 무지개블록은 다른 그룹블록 체크할 때 또 방문될 필요가 있으므로 무지개블록에 대해서 visited를 false로 돌려놓는다.

**또, 짚지 못한 포인트는 block, rainbow 리스트를 통해 각각 일반블록, 무지개블록에 대해 (행,열)을 저장하는 것이었다.**

그렇게 그룹블록 리스트에 들어갈 일반블록, 무지개블록 (행,열)정보를 각각 저장해서 그룹블록에 저장해주면 무지개블록에 대한 방문취소 처리도 쉬워지고 , 일반블록 행열 접근이 쉬워져서remove할때 사용할 수 있다.

그리고 그룹블록이 만들어지면 그 그룹블록을 그룹리스트에 담아줘서 저장해서 bfs를 통해 전체 그룹블록을 나누고 나면 한번에 sort를 진행한다.

여기서 주의할 점은, 최대그룹블록이 삭제되고 중력하고 회전하고 중력한 뒤에는 블록정보가 다 바뀌기 때문에 그룹블록을 다시 처음부터 찾아야한다.
=> 그렇기 때문에 while문에 새로돌아갈때 그룹블록 정보를 담는 리스트 group과 방문했는지 체크하는 visited를 초기화해주어야 한다는 것을 명심하자.

**마지막 실수한 점은 gravity 때문 이었는데, index와 N,M조건 실수안하도록 주의해야할 것이다.** 


[참고](https://jennnn.tistory.com/68)
